{
  "name": "Authentigo",
  "tagline": "Plug and play authentication layer higly customizable written (why not?) in pure golang",
  "body": "\r\n# AuthentiGo\r\n\r\n[![Build Status](https://travis.ibm.com/Alessio-Savi/AuthentiGo.svg?token=wWmbVrxsSXYSyYLLhamH&branch=master)](https://github.ibm.com/Alessio-Savi/AuthentiGo)\r\n\r\nSimple Golang tool that work as a \"plug-and-play\" executable for authenticate your webapplication\r\n\r\n## Getting Started\r\n\r\n### Documentation\r\n\r\n[Online documentation](https://pages.github.ibm.com/Alessio-Savi/AuthentiGo/)\r\n\r\nDuring the development of every internal tools, 90% of the time it's request to create an \"__*authentication layer*__\" in order to restrict the access to the services only to the person admitted.\r\n\r\nIn some circonstances you can simply pick up an external webserver (like *nginx/apache/happroxy*) and *proxypass/reroute* the service. If you are the root of the machine you can also forward the traffic only to the people admitted to receive it by *forwarding* the TCP traffic only to the customer allowed.\r\n\r\nBut what in case that you are a little IT Specials that *can't touch the enviroinment* and *want to restrict the access to a service using an __authentication layer__*?\r\n\r\nTaaa dan!\r\n\r\nThis tool is developed for have few HTTP API interfaces in order:\r\n\r\n- Registration layer for save customers into a database;\r\n- Login layer in order to get access to the services to the customer that have previously registered;\r\n- Restrict access to the service only for the customer that are allowed;\r\n\r\n### Features\r\n\r\n- Login phase:\r\n\r\n    -- Purpouse:\r\n\r\n        1) Auth is needed in order to receive the token;\r\n        2) Retrict the access\r\n    -- Capabilites:\r\n\r\n        * *Input valdation methods*\r\n        * *BasicAuth headers welcome*\r\n        * *Verify if user match with the one in MongoDB*\r\n        * *Generate token and set it into Redis*\r\n- Registration\r\n\r\n    -- Purpouse:\r\n\r\n        1) Save the user that can access to the services\r\n    -- Capabilities:\r\n\r\n        * *Input valdation methods*\r\n        * *BasicAuth headers welcome*\r\n        * *Persistent data saved into MongoDB*\r\n\r\n- Verification\r\n\r\n    -- Purpouse:\r\n\r\n        1) Create a middleware for \"proxypass\" the request\r\n        2) Verify the authentication of every request\r\n        3) Be as much \"standard\" as possibile in order to be used without integration issue\r\n        4) Have a performing verification layer that can be scaled @runtime\r\n    -- Capabilites:\r\n\r\n        * *RESTfull implementation*\r\n        * *Input valdation methods*\r\n        * *Redis authentication for great performance*\r\n\r\nThe tool is intended to:\r\n\r\n- Run only on Linux machine (*test on windows is appreciated*);\r\n- Bind the necessary network resources over a network device that can expose data to the network (ex: 0.0.0.0);\r\n- Consume as much low memory as possible (gzip data if request by the client);\r\n- Be scalable;\r\n- Don't steal time to the request\r\n\r\nDuring the development of the source code, I'll will try as much as i can to write modular function that can be replaced or swapped. Feel free to copy and paste the code without ask, but please license your code as a MIT licensed software\r\n\r\n## Prerequisites\r\n\r\nThe installation process is described only for __*Linux*__ machine.\r\n\r\nThe software is coded in:\r\n\r\n- Golang\r\n\r\nThe software use two different database:\r\n\r\n- MongoDB\r\n    -- Used for store the data of the customer;\r\n- Redis\r\n    -- Used for store the token of the customer in order to speed up the authentication process;\r\n\r\nFor run the software you need:\r\n\r\n1) Golang\r\n2) MongoDB\r\n3) Redis-Server\r\n\r\n### 1) Install Golang\r\n\r\nIn order to install golang in your machine, you have to run the following commands:\r\n\r\n- NOTE:\r\n  - It's preferable __*to don't run these command as root*__. Simply *`chown`* the *`root_foolder`* of golang to be compliant with your user and run the script.\r\n  - Run this \"installer\" script only once\r\n\r\n```bash\r\ngolang_version=\"1.12.4\"\r\ngolang_link=\"https://dl.google.com/go/go$golang_version.linux-amd64.tar.gz\"\r\nroot_foolder=\"/opt/GOLANG\" # Set the tree variable needed for build the enviroinment\r\ngo_source=\"$root_foolder/go\"\r\ngo_projects=\"$root_foolder/go_projects\"\r\n\r\nmkdir $root_foolder # creating dir for golang source code\r\ncd $root_foolder # entering dir\r\nwget $golang_link #downloading golang\r\ntar xf $(ls | grep \"tar\") # extract only the tar file\r\nmkdir go_projects\r\n\r\necho '\r\nexport GOPATH=\"$go_projects\"\r\nexport GOBIN=\"$GOPATH/bin\"\r\nexport GOROOT=\"$go_source\"\r\nexport PATH=\"$PATH:$GOROOT/bin:$GOBIN\"\r\n' >> /home/$(whoami)/.bashrc\r\n\r\nsource /home/$(whoami)/.bashrc\r\n\r\ngo version\r\n```\r\n\r\nAfter running these command, you have to be able to see the golang version installed.\r\n\r\n### 2) Install MongoDB\r\n\r\nIn order to install MongoDB (and some related usefull utils), you have to run the following commands:\r\n\r\n__*The following operations have to be done as root*__\r\n\r\n    ```bash\r\n    mkdir -p /opt/RPMs/MONGO\r\n    cd /opt/RPMs/MONGO\r\n    MONGO_VERSION=\"4.0.9-1.el7.x86_64\"\r\n    wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/RPMS/mongodb-org-server-$MONGO_VERSION.rpm\r\n    wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/RPMS/mongodb-org-mongos-$MONGO_VERSION.rpm\r\n    wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/RPMS/mongodb-org-tools-$MONGO_VERSION.rpm\r\n    wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.0/x86_64/RPMS/mongodb-org-shell-$MONGO_VERSION.rpm\r\n    for i in $(ls); do echo \"|Installing ==== $i ====|\"; sudo rpm -Uvh $i ; done\r\n\r\n    sudo service mongod start\r\n    ```\r\n\r\n### 3) Install Redis\r\n\r\nIn order to compile Redis from source, you have to run the following commands:\r\n\r\n__*The following operations have to be done as root*__\r\n\r\n    ```bash\r\n    mkdir /opt/Redis\r\n    cd $_\r\n    REDIS_VERSION=\"5.0.4\"\r\n    wget http://download.redis.io/releases/redis-$REDIS_VERSION.tar.gz\r\n    tar xf redis-$REDIS_VERSION.tar.gz\r\n    cd redis-$REDIS_VERSION\r\n    for i in `find . -type f | grep -v git` ; do sed -i 's/-O[[:digit:]]/-Ofast/g' $i ; done\r\n    make\r\n    make install\r\n    echo 512 > /proc/sys/net/core/somaxconn\r\n    echo vm.overcommit_memory = 1 >> /etc/sysctl.conf\r\n    sysctl -p\r\n    ```\r\n\r\n__*AUTOMATED CONFIGURATION*__:\r\n\r\nRedis came with an usefull script for automatize the install the server.\r\nIf you want to use the default configuration provided, use the following command:\r\n\r\n    ```bash\r\n    cd utils\r\n    bash install_server.sh\r\n    ```\r\n\r\nNow you have to press enter for confirm the default configuration location.\r\n\r\n#### Post Prerequisites\r\n\r\n__*NOTE*__:\r\n\r\n- *It's preferable to logout and login to the system for a fresh reload of the configuration after have installed all the packaged listed below.*\r\n\r\n## Installing\r\n\r\nThe dependendencies used by the tool can be downloaded as following:\r\nNOTE:\r\n\r\n    ```bash\r\n    go get -v -u github.com/valyala/fasthttp\r\n    go get -v -u github.com/valyala/gozstd\r\n    go get -v -u github.com/sirupsen/logrus\r\n    go get -v -u github.com/onrik/logrus/filename\r\n    go get -v -u github.com/go-redis/redis\r\n    go get -v -u github.com/globalsign/mgo\r\n    go get -v -u github.com/globalsign/mgo/bson\r\n    go get -v -u github.com/alessiosavi/GoUtils # Download the code\r\n    ```\r\n\r\nThan you have to download it manually\r\n\r\n    ```bash\r\n    cd $GOPATH/src\r\n    git clone --recursive git@github.ibm.com:Alessio-Savi/AuthentiGo.git\r\n    cd AuthentiGo\r\n    go build\r\n    ```\r\n\r\n## Running the tests\r\n\r\ngo test -v test/authentigo_test.go\r\n\r\n## Deployment\r\n\r\nYou can deploy the application in two methods:\r\n\r\n- Deploy the executable in your remote machine\r\n  - Build the source in your local machine\r\n  - Deploy the executable\r\n- Copy the code to you remote machine, run the following commands\r\n\r\n```bash\r\nscp -r authentigo.go auth/ user@machine.preprodiction.log:/home/no_sudo_user/AuthentiGo #Copy the code into your user folder\r\nssh user@machine.preprodiction.log # Log in into the machine\r\ncd /home/no_sudo_user/AuthentiGo\r\n```\r\n\r\nNow that you have a fresh version of the code and you are in the directory of the sources file\r\n\r\n    ```bash\r\n    exe=\"authentigo\" # Name of the executable generated\r\n    code=\"authentigo.go\" # Name of the main source code\r\n\r\n    echo \"Killing the process ...\"\r\n    pkill $exe # Killing all process that are named like $exe value\r\n    echo \"Deleting old code ...\"\r\n    truncate -s0 $code # Empty the file containing the old code\r\n    echo \"Copy your code\"\r\n    vi $code # Paste the code here\r\n    echo \"Cleaning old compilation files ...\"\r\n    go clean # Remove build executable\r\n    echo \"Copy the new utilies sources files ...\"\r\n    cp -r $code auth/ $GOPATH/src/authentigo # Copy the code into the $GOPATH\r\n    echo \"Building new executables ... \"\r\n    go build $code\r\n    echo \"Stripping debug symbols\"\r\n    strip -s $exe\r\n    mkdir logs # create a folder for the logs\r\n    nohup ./$exe -path utils -port 8080 > logs/logs.txt & # Just run in background\r\n    ```\r\n\r\n## Built With\r\n\r\n- [FastHTTP](https://github.com/valyala/fasthttp) - HTTP Framework | Tuned for high performance. Zero memory allocations in hot paths. Up to 10x faster than net/http\r\n- [logrus](https://github.com/Sirupsen/logrus) - Pretty logging framework | Not the fastest but very cool and customizable\r\n  - [filename](https://github.com/onrik/logrus/filename) - Plugin for logrus | Used fo print the filename and the logline at each entries of the log\r\n- [redis](https://github.com/go-redis/redis) - Useful framework for talk with Redis DB\r\n- [mgo](https://github.com/globalsign/mgo) - The MongoDB driver for Go\r\n\r\n## Contributing\r\n\r\n- Feel free to open issue in order to __*require new functionality*__\r\n- Feel free to open issue __*if you discover a bug*__\r\n- New idea/request/concept are very appreciated!\r\n\r\n## Versioning\r\n\r\nWe use [SemVer](http://semver.org/) for versioning.\r\n\r\n## Authors\r\n\r\n- **Alessio Savi** - *Initial work & Concept* - [IBM Client Innovation Center [CIC]](https://github.ibm.com/Alessio-Savi)\r\n\r\n## License\r\n\r\nThis project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details\r\n\r\n## Acknowledgments\r\n\r\nThis backend tool it's intended to run over a VPN and be served \"*proxypassed & secured*\" by a webserver like Apache or Nginx, in order to crypt the traffic and provide a good layer of security.\r\n\r\nHowever, few basic security enhancements will be developed just for fun.\r\n\r\n__*DO NOT RUN THIS TOOL AS SUDOUSERS - ROOT*__\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}